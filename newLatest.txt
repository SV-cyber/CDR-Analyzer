import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
import pandas as pd
import os
import json
import hashlib
from tkcalendar import DateEntry
from functools import lru_cache
import requests
from io import StringIO
import datetime
import shutil
import xml.etree.ElementTree as ET
import re
from bs4 import BeautifulSoup
import threading

# SMS Analysis Mapping
SMS_ENTITY_MAP = {
    "JioPay": {"Entity Name": "RELIANCE JIO INFOCOMM LIMITED", "Purpose": "Transactional/Service"},
    "KOTAKB": {"Entity Name": "Kotak Mahindra Bank Ltd", "Purpose": "Transactional/Service"},
}

USERS_PATH = "users.json"

def hash_pwd(pwd):
    return hashlib.sha256(pwd.encode()).hexdigest()

def load_users():
    if not os.path.exists(USERS_PATH):
        return {}
    with open(USERS_PATH, "r") as f:
        return json.load(f)

def save_users(users):
    with open(USERS_PATH, "w") as f:
        json.dump(users, f, indent=2)

def ensure_default_user():
    users = load_users()
    if "admin" not in users:
        users["admin"] = hash_pwd("admin")
        save_users(users)

class LoginDialog(tk.Toplevel):
    def __init__(self, master, on_success):
        super().__init__(master)
        self.title("CDR Analyzer Login")
        self.on_success = on_success
        self.geometry("350x270")
        self.resizable(True, True)
        self.attributes('-toolwindow', False)
        self.protocol("WM_DELETE_WINDOW", self.quit_app)
        tk.Label(self, text="User Login", font=("Segoe UI", 16, "bold")).pack(pady=8)
        tk.Label(self, text="User ID", font=("Segoe UI", 12)).pack()
        self.user = tk.Entry(self, font=("Segoe UI", 13))
        self.user.pack(pady=3)
        tk.Label(self, text="Password", font=("Segoe UI", 12)).pack()
        self.pwd = tk.Entry(self, font=("Segoe UI", 13), show="*")
        self.pwd.pack(pady=3)
        tk.Button(self, text="Login", command=self.try_login, font=("Segoe UI", 12, "bold"), width=20, bg="#22a", fg="white").pack(pady=8)
        tk.Button(self, text="Forgot Password", command=self.forgot_pwd, font=("Segoe UI", 11)).pack()
        tk.Button(self, text="Change Password", command=self.change_pwd, font=("Segoe UI", 11)).pack()
        self.err = tk.Label(self, text="", fg="red", font=("Segoe UI", 11))
        self.err.pack(pady=4)

    def try_login(self):
        users = load_users()
        u, p = self.user.get(), self.pwd.get()
        if u in users and users[u] == hash_pwd(p):
            self.destroy()
            self.on_success(u)
        else:
            self.err.config(text="Invalid credentials")

    def forgot_pwd(self):
        users = load_users()
        user = self.user.get() or simpledialog.askstring("Forgot Password", "Enter your user ID:")
        if user not in users:
            messagebox.showerror("Error", "User not found.")
            return
        users[user] = hash_pwd("admin")
        save_users(users)
        messagebox.showinfo("Password Reset", "Password reset to 'admin'. Please change after login.")

    def change_pwd(self):
        users = load_users()
        user = self.user.get()
        if user not in users:
            messagebox.showerror("Error", "User not found.")
            return
        old = simpledialog.askstring("Change Password", "Enter current password:", show="*")
        if users[user] != hash_pwd(old):
            messagebox.showerror("Error", "Wrong password.")
            return
        new = simpledialog.askstring("Change Password", "Enter new password:", show="*")
        users[user] = hash_pwd(new)
        save_users(users)
        messagebox.showinfo("Changed", "Password changed!")

    def quit_app(self):
        self.master.destroy()

CASES_PATH = "cases"

def ensure_cases_folder():
    if not os.path.exists(CASES_PATH):
        os.makedirs(CASES_PATH)

def save_case(case_info):
    ensure_cases_folder()
    cid = case_info["case_no"]
    with open(os.path.join(CASES_PATH, f"{cid}.json"), "w") as f:
        json.dump(case_info, f, indent=2)

def list_cases():
    ensure_cases_folder()
    return [f for f in os.listdir(CASES_PATH) if f.endswith(".json")]

def load_case(case_no):
    path = os.path.join(CASES_PATH, f"{case_no}.json")
    if os.path.exists(path):
        with open(path) as f:
            return json.load(f)
    return None

class CaseDialog(tk.Toplevel):
    def __init__(self, master, on_case_selected):
        super().__init__(master)
        self.title("Case Management")
        self.geometry("400x430")
        self.resizable(False, False)
        self.on_case_selected = on_case_selected
        self.uploaded_file = None

        nb = ttk.Notebook(self)
        nb.pack(fill="both", expand=True)

        f_add = tk.Frame(nb)
        nb.add(f_add, text="Add New Case")
        tk.Label(f_add, text="Case Number:").pack(pady=3)
        self.e_case_no = tk.Entry(f_add)
        self.e_case_no.pack(pady=2)
        tk.Label(f_add, text="Case Name:").pack(pady=3)
        self.e_case_name = tk.Entry(f_add)
        self.e_case_name.pack(pady=2)
        tk.Label(f_add, text="Investigator:").pack(pady=3)
        self.e_investigator = tk.Entry(f_add)
        self.e_investigator.pack(pady=2)
        tk.Label(f_add, text="Case Date:").pack(pady=3)
        self.e_date = DateEntry(f_add, date_pattern="dd/mm/yyyy")
        self.e_date.pack(pady=2)

        tk.Label(f_add, text="Attach CDR File:").pack(pady=3)
        self.cdr_file_label = tk.Label(f_add, text="No file chosen", fg="gray", font=("Segoe UI", 10))
        self.cdr_file_label.pack(pady=1)
        tk.Button(f_add, text="Choose File", command=self.choose_file, font=("Segoe UI", 11)).pack(pady=2)
        tk.Button(f_add, text="Save Case", command=self.save_case, bg="#0a8", fg="white", font=("Segoe UI", 11, "bold")).pack(pady=10)

        f_open = tk.Frame(nb)
        nb.add(f_open, text="Open Existing Case")
        tk.Label(f_open, text="Select Case:").pack(pady=4)
        self.case_list = tk.Listbox(f_open, height=10)
        self.case_list.pack(fill="x", padx=8)
        self.refresh_cases()
        tk.Button(f_open, text="Open Selected Case", command=self.open_selected, bg="#22a", fg="white", font=("Segoe UI", 11, "bold")).pack(pady=10)

    def choose_file(self):
        file_path = filedialog.askopenfilename(
            title="Select CDR File",
            filetypes=[
                ("All Supported Files", "*.csv *.xls *.xlsx *.xml *.json"),
                ("CSV Files", "*.csv"),
                ("Excel Files", "*.xls *.xlsx"),
                ("XML Files", "*.xml"),
                ("JSON Files", "*.json"),
                ("All Files", "*.*")
            ]
        )
        if file_path:
            self.uploaded_file = file_path
            self.cdr_file_label.config(text=os.path.basename(file_path))

    def save_case(self):
        info = {
            "case_no": self.e_case_no.get(),
            "case_name": self.e_case_name.get(),
            "investigator": self.e_investigator.get(),
            "date": self.e_date.get_date().strftime("%d/%m/%Y"),
            "cdr_filename": None
        }
        if not info["case_no"] or not info["case_name"]:
            messagebox.showerror("Missing Data", "Case Number and Name are required.")
            return
        case_folder = os.path.join(CASES_PATH, info["case_no"])
        os.makedirs(case_folder, exist_ok=True)
        cdr_dest = None
        if self.uploaded_file:
            cdr_dest = os.path.join(case_folder, os.path.basename(self.uploaded_file))
            shutil.copy2(self.uploaded_file, cdr_dest)
            info["cdr_filename"] = os.path.basename(self.uploaded_file)
        with open(os.path.join(case_folder, "case.json"), "w") as f:
            json.dump(info, f, indent=2)
        messagebox.showinfo("Saved", "Case saved.")
        self.refresh_cases()
        if cdr_dest:
            info["cdr_path"] = cdr_dest
        self.on_case_selected(info)
        self.destroy()

    def refresh_cases(self):
        self.case_list.delete(0, "end")
        for d in os.listdir(CASES_PATH):
            if os.path.isdir(os.path.join(CASES_PATH, d)):
                self.case_list.insert("end", d)

    def open_selected(self):
        idx = self.case_list.curselection()
        if not idx:
            return
        case_no = self.case_list.get(idx[0])
        case_folder = os.path.join(CASES_PATH, case_no)
        info_path = os.path.join(case_folder, "case.json")
        if os.path.exists(info_path):
            with open(info_path) as f:
                info = json.load(f)
                if info.get("cdr_filename"):
                    info["cdr_path"] = os.path.join(case_folder, info["cdr_filename"])
            self.on_case_selected(info)
            self.destroy()
        else:
            messagebox.showerror("Error", "Case data not found.")

class CDRAnalyzerApp(tk.Frame):
    def __init__(self, root, case_info):
        super().__init__(root, bg="#f4f7fa")
        self.root = root
        self.case_info = case_info
        self.df = pd.DataFrame()  # Initialize as an empty DataFrame
        self.filename = None
        self.tabs = [
            "Dashboard", "CDR", "Maximum B Party", "Max IMEI", "Max IMSI",
            "Call Max Location", "Max Day Stay", "Max Night Stay", "SMS Analysis",
            "Cell Location", "Report Generation"
        ]
        self.tab_frames = {}
        self.tab_buttons = {}
        self.a_party = None
        self.current_theme = "light"
        self.init_ui()

    def init_ui(self):
        head = tk.Frame(self, bg="#2329ad")
        head.pack(fill="x")
        tk.Label(head, text="CDRAnalayz - CDR analysis at ease | CDR Dashboard Analyzer", bg="#2329ad", fg="#fff", font=("Segoe UI", 18, "bold")).pack(side="left", padx=18, pady=6)
        self.lbl_case = tk.Label(head, text=f"Case: {self.case_info['case_name']} [{self.case_info['case_no']}]", bg="#2329ad", fg="yellow", font=("Segoe UI", 13, "bold"))
        self.lbl_case.pack(side="left", padx=16)
        tk.Button(head, text="Add/Load CDR File", command=self.load_file, font=("Segoe UI", 11, "bold"), bg="#1976d2", fg="white").pack(side="right", padx=16, pady=8)
        self.lbl_file = tk.Label(head, text="", bg="#2329ad", fg="#fff", font=("Segoe UI", 11))
        self.lbl_file.pack(side="right", padx=6)
        self.theme_button = tk.Button(head, text="Toggle Theme", command=self.toggle_theme, font=("Segoe UI", 11, "bold"), bg="#1976d2", fg="white")
        self.theme_button.pack(side="right", padx=16, pady=8)

        tabbar = tk.Frame(self, bg="#e8eaf6")
        tabbar.pack(fill="x")
        for tab in self.tabs:
            b = tk.Button(tabbar, text=tab, font=("Segoe UI", 12, "bold"), bg="#e8eaf6", relief="flat", command=lambda t=tab: self.activate_tab(t))
            b.pack(side="left", padx=2, pady=3)
            self.tab_buttons[tab] = b

        self.content_frame = tk.Frame(self, bg="#f4f7fa")
        self.content_frame.pack(fill="both", expand=True)
        self.activate_tab("Dashboard")

    def toggle_theme(self):
        if self.current_theme == "light":
            self.set_dark_theme()
        else:
            self.set_light_theme()

    def set_dark_theme(self):
        self.config(bg="#2d2d2d")
        self.current_theme = "dark"
        # Update other UI elements to dark theme

    def set_light_theme(self):
        self.config(bg="#f4f7fa")
        self.current_theme = "light"
        # Update other UI elements to light theme

    def activate_tab(self, tab):
        for t, b in self.tab_buttons.items():
            b.config(bg="#c5cae9" if t == tab else "#e8eaf6")
        for f in self.tab_frames.values():
            f.pack_forget()
        recreate = (tab == "Cell Location")
        if recreate or tab not in self.tab_frames:
            f = tk.Frame(self.content_frame, bg="#f4f7fa")
            self.tab_frames[tab] = f
            self.create_tab_content(tab, f)
        self.tab_frames[tab].pack(fill="both", expand=True)

    def load_file(self):
        path = filedialog.askopenfilename(
            title="Select CDR File",
            filetypes=[
                ("All Supported Files", "*.csv *.xls *.xlsx *.xml *.json"),
                ("CSV Files", "*.csv"),
                ("Excel Files", "*.xls *.xlsx"),
                ("XML Files", "*.xml"),
                ("JSON Files", "*.json"),
                ("All Files", "*.*")
            ]
        )
        if path:
            df = self.parse_cdr_file(path)
            if df is not None:
                self.df = df
                self.filename = os.path.basename(path)
                self.lbl_file.config(text=f"Loaded: {self.filename}")
                self.a_party = self.detect_a_party()
                self.tab_frames = {}
                self.activate_tab("Dashboard")

    def robust_read_csv(self, path):
        possible_seps = [',', '\t', ';', '|', '^', '~']
        with open(path, 'r', encoding="utf-8", errors="ignore") as f:
            lines = [line for line in f if line.strip()]
        header_idx = None
        sep = None
        for idx in range(min(30, len(lines))):
            line = lines[idx]
            for test_sep in possible_seps:
                cols = [c.strip() for c in line.strip().split(test_sep)]
                if len(cols) >= 4 and any(re.search(r'\bparty\b', c.lower()) or re.search(r'date|time|imei|imsi', c.lower()) for c in cols):
                    header_idx = idx
                    sep = test_sep
                    break
            if header_idx is not None:
                break
        if header_idx is None:
            messagebox.showerror("Could not detect header row or separator in the file. Please check file content.", parent=self)
            return None
        data_str = "".join(lines[header_idx:])
        try:
            df = pd.read_csv(StringIO(data_str), dtype=str, sep=sep, engine='python', on_bad_lines='skip')
            df.columns = [c.strip() for c in df.columns]
            if len(df.columns) < 4:
                raise Exception("Parsed too few columns")
            return df
        except Exception:
            try:
                rows = [line.strip().split(sep) for line in lines[header_idx:]]
                df = pd.DataFrame(rows[1:], columns=rows[0])
                return df
            except Exception as e2:
                messagebox.showerror("Unable to parse CSV, even with fallback.\n" + str(e2), parent=self)
                return None

    def parse_cdr_file(self, path):
        ext = os.path.splitext(path)[1].lower()
        if ext == ".csv":
            return self.robust_read_csv(path)
        elif ext in (".xls", ".xlsx"):
            df = pd.read_excel(path, dtype=str)
            df.columns = [c.strip() for c in df.columns]
            return df
        elif ext == ".json":
            with open(path, "r", encoding="utf-8") as f:
                df = pd.DataFrame(json.load(f))
            df.columns = [c.strip() for c in df.columns]
            return df
        elif ext == ".xml":
            tree = ET.parse(path)
            root = tree.getroot()
            data = [child.attrib for child in root]
            df = pd.DataFrame(data)
            df.columns = [c.strip() for c in df.columns]
            return df
        else:
            messagebox.showerror("Unsupported file type: " + ext, parent=self)
            return None

    def detect_a_party(self):
        if self.df is None or self.df.empty:
            return ""
        if "Input Value (MSISDN/B PARTY/IMEI/IMSI/CELL ID) :" in self.df.columns:
            val = self.df["Input Value (MSISDN/B PARTY/IMEI/IMSI/CELL ID) :"].iloc[0]
            return val.strip().replace("'", "").replace(",", "")
        for col in self.df.columns:
            if "called party" in col.lower():
                return self.df[col].iloc[0].strip().replace("'", "")
        return ""

    def create_tab_content(self, tab, frame):
        if self.df is None or self.df.empty:
            tk.Label(frame, text="No CDR data loaded!", font=("Segoe UI", 14, "bold"), fg="red", bg="#f4f7fa").pack(pady=20)
            return
        if tab == "Dashboard":
            self.dashboard(frame)
        elif tab == "CDR":
            self.show_table(self.df, frame, "Complete CDR Data", height=28)
        elif tab == "Maximum B Party":
            self.show_max_b_party(frame)
        elif tab == "Max IMEI":
            self.show_max_imei(frame)
        elif tab == "Max IMSI":
            self.show_max_imsi(frame)
        elif tab == "Call Max Location":
            self.show_call_max_location(frame)
        elif tab == "Max Day Stay":
            self.show_max_day_stay(frame)
        elif tab == "Max Night Stay":
            self.show_max_night_stay(frame)
        elif tab == "SMS Analysis":
            self.show_sms_analysis(frame)
        elif tab == "Cell Location":
            self.show_cell_location_tab(frame)
        elif tab == "Report Generation":
            self.report_generation(frame)

    def show_table(self, df, frame, title=None, height=28):
        if title:
            tk.Label(frame, text=title, font=("Segoe UI", 15, "bold"), bg="#f4f7fa").pack(pady=4)
        style = ttk.Style()
        style.configure("Treeview.Heading", font=("Segoe UI", 12, "bold"))
        style.configure("Treeview", font=("Segoe UI", 13), rowheight=34)
        style.map("Treeview", background=[('selected', '#1976d2')])
        style.layout("Treeview", [('Treeview.treearea', {'sticky': 'nswe'})])
        cols = list(df.columns)
        tree = ttk.Treeview(frame, columns=cols, show="headings", height=height)
        for col in cols:
            tree.heading(col, text=col)
            tree.column(col, width=180, anchor="center")
        vsb = ttk.Scrollbar(frame, orient="vertical", command=tree.yview)
        hsb = ttk.Scrollbar(frame, orient="horizontal", command=tree.xview)
        tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        tree.pack(side="left", fill="both", expand=True, padx=8, pady=4)
        vsb.pack(side="left", fill="y")
        hsb.pack(side="bottom", fill="x")
        for i, (_, row) in enumerate(df.iterrows()):
            tags = ("oddrow",) if i % 2 == 0 else ("evenrow",)
            tree.insert("", "end", values=[row[c] if pd.notna(row[c]) else "" for c in cols], tags=tags)
        style.configure("Treeview.oddrow", background="#f9f9fc")
        style.configure("Treeview.evenrow", background="#e6eef8")
        ttk.Button(frame, text="Export to Excel", command=lambda: self.export_table(df)).pack(pady=6)
        ttk.Button(frame, text="Export to PDF", command=lambda: self.export_pdf(df, title or "Report")).pack(pady=4)

    def export_table(self, df):
        path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")])
        if not path:
            return
        try:
            with pd.ExcelWriter(path, engine='openpyxl') as writer:
                current_tab = next((tab for tab, f in self.tab_frames.items() if f.winfo_ismapped()), "ExportedData")
                df.to_excel(writer, sheet_name=current_tab[:31], index=False)
                for tab in self.tabs:
                    if tab == current_tab:
                        continue
                    frame = self.tab_frames.get(tab)
                    if frame and hasattr(frame, 'df') and isinstance(frame.df, pd.DataFrame):
                        if not frame.df.empty:
                            frame.df.to_excel(writer, sheet_name=tab[:31], index=False)
            messagebox.showinfo("Success", f"Excel file exported:\n{path}", parent=self)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export Excel file.\n{str(e)}", parent=self)

    def export_pdf(self, df, title="CDR Data Export"):
        try:
            from reportlab.lib.pagesizes import A4, landscape
            from reportlab.pdfgen import canvas
            from reportlab.lib import colors
            from reportlab.platypus import Table, TableStyle, SimpleDocTemplate, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet
        except ImportError:
            messagebox.showerror("reportlab not installed. Please run: pip install reportlab")
            return
        path = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF Files", "*.pdf")])
        if not path: return
        doc = SimpleDocTemplate(path, pagesize=landscape(A4), rightMargin=30, leftMargin=30, topMargin=30,
                                bottomMargin=18)
        Story = []
        styles = getSampleStyleSheet()
        style_title = styles['Heading1']
        style_title.alignment = 0
        Story.append(Paragraph("CDR Data Export", style_title))
        Story.append(Spacer(1, 8))
        now = datetime.datetime.now().strftime("%d/%m/%Y, %I:%M:%S %p")
        Story.append(Paragraph(f"Generated on: {now}", styles['Normal']))
        Story.append(Spacer(1, 16))
        columns = [
            "Target No", "B Party", "Call FWD", "LRN", "Date", "Time", "Call TT", "Duration",
            "First Cell ID", "Last Cell ID", "Service Type", "Call Type", "SMS Center",
            "IMEI", "IMSI", "Roming"
        ]
        col_map = {col: col for col in columns}
        df = df.rename(columns=col_map)
        present_cols = [col for col in columns if col in df.columns]
        table_data = [present_cols] + df[present_cols].astype(str).values.tolist()
        t = Table(table_data, repeatRows=1)
        style = TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3759d7')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
            ('FONTSIZE', (0, 1), (-1, -1), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.whitesmoke),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.whitesmoke, colors.lightgrey]),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ])
        t.setStyle(style)
        Story.append(t)
        doc.build(Story)
        messagebox.showinfo("Exported", "PDF exported in new format.")

    def dashboard(self, frame):
        total_records = len(self.df) if self.df is not None else 0
        imei_col = self.get_col("IMEI")
        imsi_col = self.get_col("IMSI")
        cell_col = self.get_col("First Cell ID")
        b_col = self.get_col("B Party")
        imeis = self.df[imei_col].dropna().unique() if imei_col and not self.df.empty else []
        imsis = self.df[imsi_col].dropna().unique() if imsi_col and not self.df.empty else []
        cellids = self.df[cell_col].dropna().unique() if cell_col and not self.df.empty else []
        bparties = self.df[b_col].dropna().unique() if b_col and not self.df.empty else []
        top_imei = self.df[imei_col].value_counts().idxmax() if imei_col and not self.df[imei_col].empty else ""
        clean_imei = str(top_imei).strip().replace("'", "").replace(",", "")
        if clean_imei.isdigit() and len(clean_imei) >= 15:
            mkt, brand, model = self.lookup_device_info(clean_imei)
        else:
            mkt, brand, model = "Unknown", "Unknown", "Unknown"
        top_cell = self.df[cell_col].value_counts().idxmax() if cell_col and not self.df[cell_col].empty else ""
        top_loc = self.lookup_cell_location(top_cell)
        tk.Label(frame, text="CDRAnalayz - CDR analysis at ease", font=("Segoe UI", 16, "bold"), bg="#f4f7fa").pack(pady=10)
        tk.Label(frame, text="Developed for CID Ranchi", font=("Segoe UI", 14), bg="#f4f7fa").pack(pady=5)
        dash = tk.Frame(frame, bg="#f4f7fa")
        dash.pack(pady=16)
        def dash_card(master, title, value, color="#1976d2"):
            c = tk.Frame(master, bg="#fff", relief="groove", bd=2)
            c.pack(side="left", padx=18)
            tk.Label(c, text=title, font=("Segoe UI", 13, "bold"), fg=color, bg="#fff").pack(pady=7, padx=30)
            tk.Label(c, text=str(value), font=("Segoe UI", 16, "bold"), fg="#222", bg="#fff").pack(pady=7)
        dash_card(dash, "Total Records", total_records)
        dash_card(dash, "Unique IMEIs", len(imeis))
        dash_card(dash, "Unique IMSIs", len(imsis))
        dash_card(dash, "Unique Towers", len(cellids))
        dash_card(dash, "Unique B Party Nos.", len(bparties))
        dash_card(dash, "Top Device", f"{mkt}\n{brand} {model}")
        dash_card(dash, "Top Tower Location", top_loc)
        if not self.df.empty:
            tk.Label(frame, text="Sample Data (first 5 rows):", font=("Segoe UI", 14, "bold"), bg="#f4f7fa", pady=6).pack()
            self.show_table(self.df.head(5), frame, "", height=5)

    LOOKUP_COLS = {
        "Target No": ["target no", "target_no", "mobile", "mobile_no", "msisdn", "a_party", "a party", "party a"],
        "B Party": ["b party", "b_party", "called party", "called_par", "called no", "b_no", "b_number"],
        "IMEI": ["imei"],
        "IMSI": ["imsi"],
        "Duration": ["duration", "call duration", "durati"],
        "Date": ["date", "call date"],
        "Time": ["time", "call time"],
        "First Cell ID": ["first cell id", "first_cell_id", "cell id", "cellid"],
        "Last Cell ID": ["last cell id", "last_cell_id"],
        "Call FWD": ["call fwd", "call_fwd"],
        "LRN": ["lrn"],
        "Call TT": ["call tt", "call_tt"],
        "Service Type": ["service type", "service_type"],
        "Call Type": ["call type", "call_type"],
        "SMS Center": ["sms center", "sms_center"],
    }

    def get_col(self, logical_name):
        if self.df is None or self.df.empty:
            return None
        logical = logical_name.lower().replace(" ", "_")
        possible = [logical] + self.LOOKUP_COLS.get(logical_name, [])
        for col in self.df.columns:
            norm = col.lower().replace(" ", "_")
            if norm in possible or any(norm == p for p in possible):
                return col
        for col in self.df.columns:
            norm = col.lower().replace(" ", "_")
            if any(p in norm for p in possible):
                return col
        return None

    def lookup_device_info(self, imei_number):
        url = "https://investigationcamp.com/imei/imei.php"
        try:
            response = requests.post(url, data={'imeis': imei_number}, timeout=10)
            response.raise_for_status()
            soup = BeautifulSoup(response.content, 'html.parser')
            table = soup.find('table', {'id': 'resultsTable'})
            if table:
                table_row = table.find('tbody').find('tr')
                if table_row:
                    columns = table_row.find_all('td')
                    if len(columns) >= 7:
                        manufacturer = columns[6].text.strip()
                        brand = columns[4].text.strip()
                        model = columns[5].text.strip()
                        return manufacturer, brand, model
            card = soup.find('div', {'class': 'result-card'})
            if card:
                card_rows = card.find_all('div', {'class': 'card-row'})
                manufacturer = card_rows[5].find('span', {'class': 'card-value'}).text.strip()
                brand = card_rows[3].find('span', {'class': 'card-value'}).text.strip()
                model = card_rows[4].find('span', {'class': 'card-value'}).text.strip()
                return manufacturer, brand, model
        except requests.exceptions.RequestException as e:
            print(f"IMEI lookup failed for {imei_number}: {e}")
        except Exception as e:
            print(f"IMEI parsing failed for {imei_number}: {e}")
        return "Unknown", "Unknown", "Unknown"

    @lru_cache(maxsize=256)
    def lookup_cell_location(self, cell_id):
        if not cell_id or cell_id.lower() == "nan":
            return "Unknown"
        try:
            if isinstance(cell_id, float) and pd.isna(cell_id):
                return "Unknown"
            url = "https://investigationcamp.com/cell/php/api-proxy.php"
            params = {"endpoint": "cgi", "id": cell_id}
            resp = requests.get(url, params=params, timeout=10)
            resp.raise_for_status()
            data = resp.json()
            lat = data.get("latitude") or data.get("Latitude")
            lon = data.get("longitude") or data.get("Longitude")
            addr = data.get("address") or data.get("Address", "")
            city = data.get("main_city") or data.get("Main City", "")
            circle = data.get("circle") or data.get("Circle", "")
            op = data.get("operator") or data.get("Operator", "")
            if lat and lon:
                return f"{lat},{lon} - {city}, {circle} - {op} - {addr}"
            elif addr:
                return addr
            return str(data)
        except Exception as e:
            return "Unknown"

    def lookup_operator_circle(self, bparty):
        if str(bparty).startswith("89"): return "VI-HR"
        if str(bparty).startswith("93"): return "Jio-HR"
        if str(bparty).startswith("88"): return "Airtel-DL"
        if str(bparty).startswith("83"): return "Jio-DL"
        return "Unknown"

    def show_max_b_party(self, frame):
        b_col = self.get_col("B Party")
        if not b_col:
            tk.Label(frame, text="B Party column not found!", fg="red", font=("Segoe UI", 14, "bold"), bg="#f4f7fa").pack()
            return
        tgt_col = self.get_col("Target No")
        dur_col = self.get_col("Duration")
        date_col = self.get_col("Date")
        time_col = self.get_col("Time")
        result = []
        grouped = self.df.groupby(b_col)
        for b, group in grouped:
            target = group[tgt_col].iloc[0] if tgt_col else self.a_party
            if target == b:
                continue
            op = self.lookup_operator_circle(b)
            calls = len(group)
            total_secs = 0
            if dur_col in group:
                try:
                    total_secs = group[dur_col].astype(str).apply(lambda x: sum(int(t) * 60 ** i for i, t in enumerate(reversed(x.split(":")))) if ":" in x else int(x) if x.isdigit() else 0).sum()
                except:
                    total_secs = 0
            if date_col and time_col:
                dt = pd.to_datetime(group[date_col] + " " + group[time_col], errors="coerce", dayfirst=True)
                first_call = dt.min()
                last_call = dt.max()
            else:
                first_call = last_call = ""
            result.append([
                target, b, op, calls, str(pd.to_timedelta(total_secs, unit='s')),
                first_call if not pd.isnull(first_call) else "",
                last_call if not pd.isnull(last_call) else ""
            ])
        out = pd.DataFrame(sorted(result, key=lambda x: x[3], reverse=True), columns=[
            "Target No", "B Party", "Operator & Circle", "Max Calls", "Max Call Duration", "First Call", "Last Call"
        ]).head(30)
        self.show_table(out, frame, "Maximum B Party Table")

    def show_max_imei(self, frame):
        imei_col = self.get_col("IMEI")
        tgt_col = self.get_col("Target No")
        dur_col = self.get_col("Duration")
        date_col, time_col = self.get_col("Date"), self.get_col("Time")
        b_col = self.get_col("B Party")
        if not imei_col:
            tk.Label(frame, text="IMEI column not found!", fg="red", font=("Segoe UI", 14, "bold"), bg="#f4f7fa").pack()
            return

        loading_popup = LoadingPopup(self.root, "Looking up IMEI information...")

        def do_lookup():
            result = []
            for imei, group in self.df.groupby(imei_col):
                target = group[tgt_col].iloc[0] if tgt_col else self.a_party
                calls = len(group)
                tot_secs = 0
                if dur_col in group:
                    try:
                        tot_secs = group[dur_col].astype(str).apply(lambda x: sum(
                            int(t) * 60 ** i for i, t in enumerate(reversed(x.split(":")))) if ":" in x else int(
                            x) if x.isdigit() else 0).sum()
                    except:
                        tot_secs = 0
                if date_col and time_col:
                    dt = pd.to_datetime(group[date_col] + " " + group[time_col], errors="coerce", dayfirst=True)
                    first_call = dt.min()
                    last_call = dt.max()
                    first_b = group.loc[dt.idxmin()][b_col] if b_col and not pd.isnull(dt.min()) else ""
                    last_b = group.loc[dt.idxmax()][b_col] if b_col and not pd.isnull(dt.max()) else ""
                else:
                    first_call = last_call = first_b = last_b = ""
                clean_imei = str(imei).strip().replace("'", "").replace(",", "")
                if clean_imei.isdigit() and len(clean_imei) == 15:
                    mkt, brand, model = self.lookup_device_info(clean_imei)
                else:
                    mkt, brand, model = "Unknown", "Unknown", "Unknown"
                result.append([
                    target, imei, calls, str(pd.to_timedelta(tot_secs, unit='s')),
                    first_call if not pd.isnull(first_call) else "",
                    first_b, last_call if not pd.isnull(last_call) else "", last_b,
                    mkt, brand, model
                ])

            out = pd.DataFrame(sorted(result, key=lambda x: x[2], reverse=True), columns=[
                "Target", "IMEI", "Call Count", "Total Duration", "First Call Date Time", "First Call B Party",
                "Last Call Date Time", "Last Call B Party", "Marketing Name", "Brand Name", "Model Name"
            ]).head(30)

            def show_table_on_main():
                loading_popup.destroy()
                self.show_table(out, frame, "Max IMEI Table")

            self.root.after(0, show_table_on_main)

        threading.Thread(target=do_lookup, daemon=True).start()

    def show_max_imsi(self, frame):
        imsi_col = self.get_col("IMSI")
        tgt_col = self.get_col("Target No")
        date_col, time_col = self.get_col("Date"), self.get_col("Time")
        if not imsi_col:
            tk.Label(frame, text="IMSI column not found!", fg="red", font=("Segoe UI", 14, "bold"), bg="#f4f7fa").pack()
            return
        result = []
        for imsi, group in self.df.groupby(imsi_col):
            target = group[tgt_col].iloc[0] if tgt_col else self.a_party
            count = len(group)
            if date_col and time_col:
                dt = pd.to_datetime(group[date_col] + " " + group[time_col], errors="coerce", dayfirst=True)
                first = dt.min()
                last = dt.max()
            else:
                first = last = ""
            result.append([target, imsi, count, first if not pd.isnull(first) else "", last if not pd.isnull(last) else ""])
        out = pd.DataFrame(sorted(result, key=lambda x: x[2], reverse=True), columns=[
            "Target", "IMSI", "Count", "First Usage", "Last Usage"
        ]).head(30)
        self.show_table(out, frame, "Max IMSI Table")

    def show_call_max_location(self, frame):
        cell_col = self.get_col("First Cell ID")
        tgt_col = self.get_col("Target No")
        dur_col = self.get_col("Duration")
        b_col = self.get_col("B Party")
        date_col = self.get_col("Date")
        time_col = self.get_col("Time")

        if not cell_col:
            tk.Label(frame, text="Cell ID column not found!", fg="red", font=("Segoe UI", 14, "bold"), bg="#f4f7fa").pack()
            return

        result = []
        for cell, group in self.df.groupby(cell_col):
            target = group[tgt_col].iloc[0] if tgt_col else self.a_party
            calls = len(group)
            total_secs = 0
            if dur_col in group:
                try:
                    total_secs = group[dur_col].astype(str).apply(
                        lambda x: sum(int(t) * 60 ** i for i, t in enumerate(reversed(x.split(":"))))
                        if ":" in x else int(x) if x.isdigit() else 0
                    ).sum()
                except:
                    total_secs = 0
            if date_col and time_col:
                dt = pd.to_datetime(group[date_col] + " " + group[time_col], errors="coerce", dayfirst=True)
                first_call = dt.min()
                last_call = dt.max()
                first_b = group.loc[dt.idxmin()][b_col] if b_col and not pd.isnull(dt.min()) else ""
                last_b = group.loc[dt.idxmax()][b_col] if b_col and not pd.isnull(dt.max()) else ""
            else:
                first_call = last_call = first_b = last_b = ""
            result.append([target, cell, calls, str(pd.to_timedelta(total_secs, unit='s')), first_call, first_b, last_call, last_b])

        out = pd.DataFrame(sorted(result, key=lambda x: x[2], reverse=True), columns=[
            "Target", "Cell ID", "Call Count", "Duration", "First Call DateTime", "First Call B", "Last Call DateTime", "Last Call B"
        ]).head(30)

        self.show_table(out, frame, "Call Max Location Table")

    def show_max_day_stay(self, frame):
        date_col, time_col = self.get_col("Date"), self.get_col("Time")
        if not date_col or not time_col:
            tk.Label(frame, text="Date or Time column not found!", fg="red", font=("Segoe UI", 14, "bold"), bg="#f4f7fa").pack()
            return
        dt = pd.to_datetime(self.df[date_col] + " " + self.df[time_col], errors="coerce", dayfirst=True)
        mask = dt.dt.time >= datetime.time(6, 0, 0)
        mask &= dt.dt.time <= datetime.time(18, 0, 0)
        df_day = self.df[mask]
        self.show_table(df_day, frame, "Max Day Stay (06:00–18:00)", height=16)

    def show_max_night_stay(self, frame):
        date_col, time_col = self.get_col("Date"), self.get_col("Time")
        if not date_col or not time_col:
            tk.Label(frame, text="Date or Time column not found!", fg="red", font=("Segoe UI", 14, "bold"), bg="#f4f7fa").pack()
            return
        dt = pd.to_datetime(self.df[date_col] + " " + self.df[time_col], errors="coerce", dayfirst=True)
        mask = (dt.dt.time < datetime.time(6, 0, 0)) | (dt.dt.time > datetime.time(18, 0, 0))
        df_night = self.df[mask]
        self.show_table(df_night, frame, "Max Night Stay (18:01–05:59)", height=16)

    def show_sms_analysis(self, frame):
        b_col = self.get_col("B Party")
        if not b_col:
            tk.Label(frame, text="B Party column (SMS Code) not found!", fg="red", font=("Segoe UI", 14, "bold"), bg="#f4f7fa").pack()
            return
        result = {}
        for code in self.df[b_col]:
            code = str(code).strip()
            if not code:
                continue
            result[code] = result.get(code, 0) + 1
        rows = []
        for code, count in sorted(result.items(), key=lambda x: x[1], reverse=True):
            entity_info = SMS_ENTITY_MAP.get(code, {"Entity Name": "Unknown", "Purpose": "Unknown"})
            rows.append([code, count, entity_info["Entity Name"], entity_info["Purpose"]])
        out = pd.DataFrame(rows, columns=["SMS Code", "Count", "Entity Name", "Purpose"])
        self.show_table(out, frame, "SMS Analysis Table")

    def report_generation(self, frame):
        tk.Label(frame, text="Report Generation", font=("Segoe UI", 16, "bold"), bg="#f4f7fa").pack(pady=10)
        tk.Button(frame, text="Export to PDF", command=lambda: self.export_pdf(self.df, "Complete CDR Data"), font=("Segoe UI", 12, "bold"), bg="#1976d2", fg="white").pack(pady=10)
        tk.Button(frame, text="Export to Excel", command=lambda: self.export_table(self.df), font=("Segoe UI", 12, "bold"), bg="#1976d2", fg="white").pack(pady=10)

    def normalize_cell_id(self, cell_id_raw):
        if not isinstance(cell_id_raw, str):
            cell_id_raw = str(cell_id_raw)
        cell_id_raw = cell_id_raw.strip().replace("'", "").replace("\"", "").replace(" ", "")
        if ',' in cell_id_raw:
            parts = cell_id_raw.split(',')
        elif ';' in cell_id_raw:
            parts = cell_id_raw.split(';')
        elif '/' in cell_id_raw:
            parts = cell_id_raw.split('/')
        else:
            parts = [cell_id_raw]
        cleaned = []
        for cid in parts:
            cid = cid.strip().replace("-", "").replace("_", "")
            cid = re.sub(r"[^A-Za-z0-9]", "", cid)
            if cid:
                cleaned.append(cid)
        return cleaned

    def show_cell_location_tab(self, frame):
        first_col = self.get_col("First Cell ID")
        last_col = self.get_col("Last Cell ID")
        if not first_col and not last_col:
            tk.Label(frame, text="Cell ID columns not found!", fg="red", font=("Segoe UI", 14, "bold"), bg="#f4f7fa").pack()
            return

        loading_popup = LoadingPopup(self.root, "Looking up cell locations...")

        def do_lookup():
            unique_cell_ids = set()
            for _, row in self.df.iterrows():
                for col in [first_col, last_col]:
                    val = row[col] if col and col in row else ""
                    for cid in self.normalize_cell_id(val) if val else []:
                        unique_cell_ids.add(cid)
            unique_cell_ids = list(unique_cell_ids)
            cellid_to_location = {}
            for cid in unique_cell_ids:
                cellid_to_location[cid] = self.lookup_cell_location(cid)
            rows = []
            for idx, row in self.df.iterrows():
                first_val = row[first_col] if first_col in row else ""
                last_val = row[last_col] if last_col and last_col in row else ""
                ids_first = self.normalize_cell_id(first_val) if first_val else []
                ids_last = self.normalize_cell_id(last_val) if last_val else []
                if ids_first and ids_last and ids_first == ids_last:
                    cell_id = ids_first[0]
                    loc = cellid_to_location.get(cell_id, "Unknown")
                    summary_row = {
                        "Index": idx + 1,
                        "First Cell ID": cell_id,
                        "First Location": loc,
                        "Last Cell ID": cell_id,
                        "Last Location": loc
                    }
                else:
                    summary_row = {
                        "Index": idx + 1,
                        "First Cell ID": ids_first[0] if ids_first else "",
                        "First Location": cellid_to_location.get(ids_first[0], "") if ids_first else "",
                        "Last Cell ID": ids_last[0] if ids_last else "",
                        "Last Location": cellid_to_location.get(ids_last[0], "") if ids_last else ""
                    }
                rows.append(summary_row)

            def show_table_on_main():
                loading_popup.destroy()
                df_out = pd.DataFrame(rows)
                self.show_table(df_out, frame, "Cell Location Lookup Table", height=20)

            self.root.after(0, show_table_on_main)

        threading.Thread(target=do_lookup, daemon=True).start()

class LoadingPopup(tk.Toplevel):
    def __init__(self, parent, message="Loading, please wait..."):
        super().__init__(parent)
        self.title("Loading")
        self.geometry("300x100")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", lambda: None)
        tk.Label(self, text=message, font=("Segoe UI", 13, "bold")).pack(expand=True, pady=25)
        self.update()

class MainApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.withdraw()
        ensure_default_user()
        self.login_screen()

    def login_screen(self):
        LoginDialog(self, self.launch_case_mgmt)

    def launch_case_mgmt(self, user_id):
        self.user_id = user_id
        CaseDialog(self, self.launch_cdr_analyzer)

    def launch_cdr_analyzer(self, case_info):
        self.case_info = case_info
        self.deiconify()
        self.geometry("1600x900")
        self.title(f"CDR Analyzer - {case_info['case_name']} [{case_info['case_no']}]")
        for w in self.winfo_children():
            w.destroy()
        CDRAnalyzerApp(self, case_info).pack(fill="both", expand=True)

if __name__ == "__main__":
    try:
        from tkcalendar import DateEntry
    except ImportError:
        messagebox.showerror("tkcalendar missing", "Run: pip install tkcalendar")
        exit(1)
    MainApp().mainloop()
